#!/usr/bin/env python
# -*- coding: utf-8 -*-

""" print "this is XunFeng Liao's Python 2.7 tutorial" """

import math
import os  # 导入os模块，模块的概念后面讲到

# 第一个Python程序-------------------------------------------------------------------------------------------------------
# print 'hello world'
# ----------------------------------------------------------------------------------------------------------------------

# 输入和输出-------------------------------------------------------------------------------------------------------------
# print 'The quick brown fox', 'jumps over', 'the lazy dog'
# # print会依次打印每个字符串，遇到逗号“,”会输出一个空格
# name = raw_input('please enter your name: ')
# print 'hello,', name
# ----------------------------------------------------------------------------------------------------------------------

# Python基础-------------------------------------------------------------------------------------------------------------
# # print absolute value of an integer:
# a = 100
# if a >= 0:
#     print a
# else:
#     print -a
# # 以#开头的语句是注释，注释是给人看的，可以是任意内容，解释器会忽略掉注释。其他每一行都是一个语句，当语句以冒号“:”结尾时，缩进的语句视为代码块。
# # 缩进有利有弊。好处是强迫你写出格式化的代码，但没有规定缩进是几个空格还是Tab。按照约定俗成的管理，应该始终坚持使用4个空格的缩进。
# ----------------------------------------------------------------------------------------------------------------------

# 数据类型和变量----------------------------------------------------------------------------------------------------------
# print r'\\\t\\'
# # 为了简化，Python还允许用r''表示''内部的字符串默认不转义
# print '''line1
# line2
# line3'''
# # Python允许用'''...'''的格式表示多行内容
# a = 123  # a是整数
# print a
# a = 'ABC'  # a变为字符串
# print a
# # 在Python中，等号=是赋值语句，可以把任意数据类型赋值给变量，同一个变量可以反复赋值，而且可以是不同类型的变量
# # 这种变量本身类型不固定的语言称之为动态语言，与之对应的是静态语言。静态语言在定义变量时必须指定变量类型，如果赋值的时候类型不匹配，就会报错
#
# print 'Hello, %s' % 'world'
# print 'Hi, %s, you have $%d.' % ('Michael', 1000000)
# # 常见的占位符有：
# #
# # %d	整数
# # %f	浮点数
# # %s	字符串
# # %x	十六进制整数
#
# # 格式化整数和浮点数还可以指定是否补0和整数与小数的位数
# print '%2d-%02d' % (3, 1)
# print '%9.2f' % 3.1415926
# # 可以在"%"和字母之间插进数字表示最大场宽。
# # 例如: %3d 表示输出3位整型数, 不够3位右对齐。
# # %9.2f 表示输出场宽为9的浮点数, 其中小数位为2, 整数位为6,
# # 小数点占一位, 不够9位右对齐。
#
# print u'中文'.encode('utf-8')
# print '\xe4\xb8\xad\xe6\x96\x87'.decode('utf-8')
# ----------------------------------------------------------------------------------------------------------------------

# 使用list和tuple--------------------------------------------------------------------------------------------------------
# classmates = ['Michael', 'Bob', 'Tracy']
# print classmates
# # 用len()函数可以获得list元素的个数
# print len(classmates)
# # 用索引来访问list中每一个位置的元素，记得索引是从0开始的
# print classmates[0]
# print classmates[1]
# print classmates[2]
# # print classmates[3]  # error
# # list是一个可变的有序表，所以，可以往list中追加元素到末尾
# classmates.append('Adam')
# print classmates
# # 也可以把元素插入到指定的位置，比如索引号为1的位置
# classmates.insert(1, 'Jack')
# print classmates
# # 要删除list末尾的元素，用pop()方法
# print classmates.pop()
# print classmates
# # 要删除指定位置的元素，用pop(i)方法，其中i是索引位置
# print classmates.pop(1)
# print classmates
# # 要把某个元素替换成别的元素，可以直接赋值给对应的索引位置
# classmates[1] = 'Sarah'
# print classmates
# # list里面的元素的数据类型也可以不同
# L = ['Apple', 123, True]
# # list元素也可以是另一个list
# s = ['python', 'java', ['asp', 'php'], 'scheme']
# print s
# print s[2]
# # 要拿到'php'可以写p[1]或者s[2][1]，因此s可以看成是一个二维数组
# print s[2][1]
# print '\n'
#
# # 另一种有序列表叫元组：tuple。tuple和list非常类似，但是tuple一旦初始化就不能修改
# classmates = ('Michael', 'Bob', 'Tracy')
# print classmates
# # 但是，要定义一个只有1个元素的tuple  t = (1,)
# t = ('a', 'b', ['A', 'B'])
# t[2][0] = 'X'
# t[2][1] = 'Y'
# print t
# # 表面上看，tuple的元素确实变了，但其实变的不是tuple的元素，而是list的元素。tuple一开始指向的list并没有改成别的list，所以，tuple所谓的“不变”是说，tuple的每个元素，指向永远不变
# ----------------------------------------------------------------------------------------------------------------------

# 条件判断和循环----------------------------------------------------------------------------------------------------------
# age = 3
# if age >= 18:
#     print 'your age is', age
#     print 'adult'
# else:
#     print 'your age is', age
#     print 'teenager'
#
# age = 3
# if age >= 18:
#     print 'adult'
# elif age >= 6:
#     print 'teenager'
# else:
#     print 'kid'
#
# names = ['Michael', 'Bob', 'Tracy']
# for name in names:
#     print name
#
# sum = 0
# for x in [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]:
#     sum += x
# print sum
#
# # Python提供一个range()函数，可以生成一个整数序列，比如range(5)生成的序列是从0开始小于5的整数
# sum = 0
# for x in range(101):
#     sum += x
# print sum
#
# sum = 0
# n = 99
# while n > 0:
#     sum += n
#     n -= 2
# print sum
#
# birth = int(raw_input('birth: '))
# if birth < 2000:
#     print '00前'
# else:
#     print '00后'
# ----------------------------------------------------------------------------------------------------------------------

# 使用dict和set----------------------------------------------------------------------------------------------------------
# # Python内置了字典：dict的支持，dict全称dictionary，在其他语言中也称为map，使用键-值（key-value）存储，具有极快的查找速度
# d = {'Michael': 95, 'Bob': 75, 'Tracy': 85}
# print d['Bob']
# # 要避免key不存在的错误，通过dict提供的get方法，如果key不存在，可以返回None，或者自己指定的value
# print d.get('Thomas', -1)
# # 要删除一个key，用pop(key)方法，对应的value也会从dict中删除
# print d.get('Bob', -1)
# d.pop('Bob')
# print d.get('Bob', -1)
# print d
# # 要保证hash的正确性，作为key的对象就不能变。在Python中，字符串、整数等都是不可变的，因此，可以放心地作为key。而list是可变的，就不能作为key
# key = [1, 2, 3]
# # d[key] = 'a list'
#
# # set和dict类似，也是一组key的集合，但不存储value。由于key不能重复，所以，在set中，没有重复的key
# s = set([1, 2, 3])
# print s
# s = set([1, 1, 2, 2, 3, 3])
# print s
# # 通过add(key)方法可以添加元素到set中，可以重复添加，但不会有效果
# s.add(4)
# print s
# s.add(4)
# print s
# # 通过remove(key)方法可以删除元素
# s.remove(4)
# print s
# # set可以看成数学意义上的无序和无重复元素的集合，因此，两个set可以做数学意义上的交集、并集等操作
# s1 = set([1, 2, 3])
# s2 = set([2, 3, 4])
# print s1 & s2
# print s1 | s2
#
# # 对于可变对象，比如list，对list进行操作，list内部的内容是会变化的
# a = ['c', 'b', 'a']
# a.sort()
# print a
# a = 'abc'
# b = a.replace('a', 'A')
# print b
# print a
# ----------------------------------------------------------------------------------------------------------------------

# 调用函数---------------------------------------------------------------------------------------------------------------
# # 比较函数cmp(x, y)就需要两个参数，如果x<y，返回-1，如果x==y，返回0，如果x>y，返回1
# print cmp(1, 2)
# print cmp(1, 1)
# print cmp(2, 1)
#
# print int('123')
# print unicode(100)
# ----------------------------------------------------------------------------------------------------------------------

# 定义函数---------------------------------------------------------------------------------------------------------------
#
#
# # 定义一个函数要使用def语句，依次写出函数名、括号、括号中的参数和冒号:，然后，在缩进块中编写函数体，函数的返回值用return语句返回
# def my_abs(x):
#     if x >= 0:
#         return x
#     else:
#         return -x
# print my_abs(5)
# print my_abs(-5)
#
# # pass可以用来作为占位符
# age = 5
# if age >= 18:
#     pass
#
#
# # 对参数类型做检查，只允许整数和浮点数类型的参数。数据类型检查可以用内置函数isinstance实现
# def my_abs(x):
#     if not isinstance(x, (int, float)):
#         raise TypeError('bad operand type')
#     if x >= 0:
#         return x
#     else:
#         return -x
# print my_abs(12)
#
#
# def move(x, y, step, angle=0):
#     nx = x + step * math.cos(angle)
#     ny = y - step * math.sin(angle)
#     return nx, ny
# x, y = move(100, 100, 60, math.pi / 6)
# print x, y
# ----------------------------------------------------------------------------------------------------------------------

# 函数的参数-------------------------------------------------------------------------------------------------------------
#
#
# def power(x, n=2):
#     s = 1
#     while n > 0:
#         n -= 1
#         s *= x
#     return s
# print power(5)
# print power(5, 3)
# # 一是必选参数在前，默认参数在后，否则Python的解释器会报错
# # 当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数
#
#
# def enroll(name, gender, age=6, city='Beijing'):
#     print 'name:', name
#     print 'gender:', gender
#     print 'age:', age
#     print 'city:', city
# # 有多个默认参数时，调用的时候，既可以按顺序提供默认参数，比如调用enroll('Bob', 'M', 7)，意思是，除了name，gender这两个参数外，最后1个参数应用在参数age上，city参数由于没有提供，仍然使用默认值
# # 也可以不按顺序提供部分默认参数。当不按顺序提供部分默认参数时，需要把参数名写上。比如调用enroll('Adam', 'M', city='Tianjin')，意思是，city参数用传进去的值，其他默认参数继续使用默认值
# enroll('Adam', 'M', city='Tianjin')
#
#
# def add_end(l=[]):
#     l.append('END')
#     return l
# print add_end([1, 2, 3])
# print add_end(['x', 'y', 'z'])
#
# print add_end()
# # 再次调用add_end()时，结果就不对了
# print add_end()
# # Python函数在定义的时候，默认参数l的值就被计算出来了，即[]，因为默认参数l也是一个变量，它指向对象[]，每次调用该函数，如果改变了l的内容，则下次调用时，默认参数的内容就变了，不再是函数定义时的[]了
# # 所以，定义默认参数要牢记一点：默认参数必须指向不变对象!
#
#
# def add_end(l=None):
#     if l is None:
#         l = []
#     l.append('END')
#     return l
# print add_end()
# print add_end()
# # 为什么要设计str、None这样的不变对象呢？因为不变对象一旦创建，对象内部的数据就不能修改，这样就减少了由于修改数据导致的错误。此外，由于对象不变，多任务环境下同时读取对象不需要加锁，同时读一点问题都没有。我们在编写程序时，如果可以设计一个不变对象，那就尽量设计成不变对象
#
#
# def calc(*numbers):
#     sum = 0
#     for n in numbers:
#         sum += n * n
#     return sum
# # 定义可变参数和定义list或tuple参数相比，仅仅在参数前面加了一个*号。在函数内部，参数numbers接收到的是一个tuple，因此，函数代码完全不变。但是，调用该函数时，可以传入任意个参数，包括0个参数
# print calc(1, 2)
# print calc()
#
# # Python允许你在list或tuple前面加一个*号，把list或tuple的元素变成可变参数传进去
# nums = [1, 2, 3]
# print calc(*nums)
# # 这种写法相当有用，而且很常见
#
#
# def person(name, age, **kw):
#     print 'name:', name, 'age:', age, 'other:', kw
# person('Adam', 45, gender='M', job='Engineer')
# # 关键字参数有什么用？它可以扩展函数的功能。比如，在person函数里，我们保证能接收到name和age这两个参数，但是，如果调用者愿意提供更多的参数，我们也能收到。试想你正在做一个用户注册的功能，除了用户名和年龄是必填项外，其他都是可选项，利用关键字参数来定义这个函数就能满足注册的需求
#
#
# # 参数定义的顺序必须是：必选参数、默认参数、可变参数和关键字参数
# def func(a, b, c=0, *args, **kw):
#     print 'a =', a, 'b =', b, 'c =', c, 'args =', args, 'kw =', kw
# func(1, 2)
# func(1, 2, c=3)
# func(1, 2, 3, 'a', 'b')
# func(1, 2, 3, 'a', 'b', x=99)
#
# args = (1, 2, 3, 4)
# kw = {'x': 99}
# func(*args, **kw)
# # 对于任意函数，都可以通过类似func(*args, **kw)的形式调用它，无论它的参数是如何定义的
#
# # 要注意定义可变参数和关键字参数的语法：
# # *args是可变参数，args接收的是一个tuple；
# # **kw是关键字参数，kw接收的是一个dict。
# # 以及调用函数时如何传入可变参数和关键字参数的语法：
# # 可变参数既可以直接传入：func(1, 2, 3)，又可以先组装list或tuple，再通过*args传入：func(*(1, 2, 3))；
# # 关键字参数既可以直接传入：func(a=1, b=2)，又可以先组装dict，再通过**kw传入：func(**{'a': 1, 'b': 2})。
# ----------------------------------------------------------------------------------------------------------------------

# 递归函数---------------------------------------------------------------------------------------------------------------
#
#
# def fact(n):
#     if n==1:
#         return 1
#     return n * fact(n - 1)
# print fact(5)
# print fact(100)
# # print fact(1000)
# # 递归调用的次数过多，会导致栈溢出
# # 解决递归调用栈溢出的方法是通过尾递归优化
# # 尾递归是指，在函数返回的时候，调用自身本身，并且，return语句不能包含表达式。这样，编译器或者解释器就可以把尾递归做优化，使递归本身无论调用多少次，都只占用一个栈帧，不会出现栈溢出的情况
#
#
# def fact(n):
#     return fact_iter(n, 1)
#
#
# def fact_iter(num, product):
#     if num == 1:
#         return product
#     return fact_iter(num - 1, num * product)
# print fact(5)
# # Python标准的解释器没有针对尾递归做优化，任何递归函数都存在栈溢出的问题
# ----------------------------------------------------------------------------------------------------------------------

# 切片------------------------------------------------------------------------------------------------------------------
# L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
# print L[0:3]
# # L[0:3]表示，从索引0开始取，直到索引3为止，但不包括索引3。即索引0，1，2，正好是3个元素
# L = range(100)
# # 前10个数
# print L[:10]
# # 后10个数
# print L[-10:]
# # 前11-20个数
# print L[10:20]
# # 前10个数，每两个取一个
# print L[:10:2]
# # 所有数，每5个取一个
# print L[::5]
#
# print 'ABCDEFG'[:3]
# print 'ABCDEFG'[::2]
# tmp = 'ABCDEFGHIJKLMN'[0:5]
# print tmp
# ----------------------------------------------------------------------------------------------------------------------

# 迭代------------------------------------------------------------------------------------------------------------------
# # 默认情况下，dict迭代的是key。如果要迭代value，可以用for value in d.itervalues()，如果要同时迭代key和value，可以用for k, v in d.iteritems()
# d = {'a': 1, 'b': 2, 'c': 3}
# for key in d:
#     print key
# for value in d.itervalues():
#     print value
# for k, v in d.iteritems():
#     print k, v
#
# # 字符串也是可迭代对象
# for ch in 'ABC':
#     print ch
# from collections import Iterable
# print isinstance('abc', Iterable)  # str是否可迭代
# print isinstance([1, 2, 3], Iterable)  # list是否可迭代
# print isinstance(123, Iterable)  # 整数是否可迭代
#
# # Python内置的enumerate函数可以把一个list变成索引-元素对，这样就可以在for循环中同时迭代索引和元素本身
# tmp = 'abcdefghijklmn'
# for i, value in enumerate(tmp):
#     print i, value
#
# for x, y in [(1, 1), (2, 4), (3, 9)]:
#     print x, y
# ----------------------------------------------------------------------------------------------------------------------

# 列表生成式-------------------------------------------------------------------------------------------------------------
# print [x * x for x in range(1, 11)]
# print [x * x for x in range(1, 11) if x % 2 == 0]
# # 还可以使用两层循环，可以生成全排列
# print [m + n for m in 'ABC' for n in 'XYZ']
#
# # 列出当前目录下的所有文件和目录名
# print [d for d in os.listdir('.')]  # os.listdir可以列出文件和目录
#
# d = {'x': 'A', 'y': 'B', 'z': 'C'}
# print [k + '=' + v for k, v in d.iteritems()]
#
# # 把一个list中所有的字符串变成小写
# L = ['Hello', 'World', 'IBM', 'Apple']
# print [s.lower() for s in L]
#
# L = ['Hello', 'World', 18, 'Apple', None]
# print [s.lower() if isinstance(s, str) else s for s in L]
# ----------------------------------------------------------------------------------------------------------------------

# 生成器-----------------------------------------------------------------------------------------------------------------
# # 在Python中，这种一边循环一边计算的机制，称为生成器（Generator）
# L = [x * x for x in range(10)]
# # 第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator
# g = (x * x for x in range(10))
# print g.next()
# print g.next()
# print g.next()
#
# for n in g:
#     print n
#
#
# # 斐波拉契数列（Fibonacci）
# def fib(max):
#     n, a, b = 0, 0, 1
#     while n < max:
#         print b
#         a, b = b, a + b
#         n = n + 1
# fib(6)
#
#
# # 这就是定义generator的另一种方法。如果一个函数定义中包含yield关键字，那么这个函数就不再是一个普通函数，而是一个generator
# def fib(max):
#     n, a, b = 0, 0, 1
#     while n < max:
#         yield b
#         a, b = b, a + b
#         n = n + 1
# # 最难理解的就是generator和函数的执行流程不一样。函数是顺序执行，遇到return语句或者最后一行函数语句就返回。而变成generator的函数，在每次调用next()
# # 的时候执行，遇到yield语句返回，再次执行时从上次返回的yield语句处继续执行
#
#
# def odd():
#     print 'step 1'
#     yield 1
#     print 'step 2'
#     yield 3
#     print 'step 3'
#     yield 5
# o = odd()
# o.next()
# o.next()
# o.next()
# o.next()
# ----------------------------------------------------------------------------------------------------------------------



